/* Copyright Davain Pablo Edwards core8@gmx.net. Licensed https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en */
package de.webstore.backend.service;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import de.webstore.backend.dto.OrderDTO;
import de.webstore.backend.dto.PositionDTO;
import de.webstore.backend.exception.InsufficientStockException;
import de.webstore.backend.exception.OrderClosedException;
import de.webstore.backend.exception.OrderNotFoundException;
import de.webstore.backend.exception.PositionNotFoundException;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import de.webstore.backend.config.DatabaseConnection;

/**
 * Service layer for managing orders.
 * <p>
 * This class provides services for retrieving, creating, and managing orders and their positions,
 * interfacing with the database to perform these operations.
 */
@Service
public class OrderService {

    // Database connection dependency injected by Spring
    private final DatabaseConnection databaseConnection;

    @Autowired
    public OrderService(DatabaseConnection databaseConnection) {
        this.databaseConnection = databaseConnection;
    }

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * Retrieves all orders from the database.
     *
     * @return a list of all orders
     */
    public List<OrderDTO> findAll() {
        List<OrderDTO> orders = new ArrayList<>();
        String sql = "SELECT * FROM auftrag";

        // Try-with-resources statement ensures that each resource is closed at the end of the statement
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql);
             ResultSet rs = pstmt.executeQuery()) {
            
            while (rs.next()) {
                OrderDTO order = new OrderDTO();
                order.setOrderId(rs.getString("auftragsnummer"));
                order.setDate(rs.getDate("Datum").toLocalDate());
                order.setStatus(rs.getString("status"));
                orders.add(order);
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
        return orders;
    }

    /**
     * Finds a specific order by its ID and throws OrderNotFoundException if not found.
     *
     * @param orderId the order ID
     * @return the found order
     * @throws OrderNotFoundException if the order with the given ID is not found
     */
    public OrderDTO findById(String orderId) {
        OrderDTO order = null;
        String sql = "SELECT * FROM auftrag WHERE auftragsnummer = ?";

        try (Connection conn = databaseConnection.getConnection();
            PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            pstmt.setString(1, orderId);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    order = new OrderDTO();
                    order.setOrderId(rs.getString("auftragsnummer"));
                    order.setStatus(rs.getString("status"));
                    order.setDate(rs.getDate("datum").toLocalDate());
                } else {
                    // If the order with the specified ID is not found, throw OrderNotFoundException
                    throw new OrderNotFoundException("Order with ID " + orderId + " not found.");
                }
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            // Consider wrapping and rethrowing SQLException as a runtime exception or a custom checked exception
        }
        return order;
    }

    /**
     * Creates a new order in the database.
     *
     * @param orderDTO the order to be created
     * @return the created order with its new ID
     */
    public OrderDTO createOrder(OrderDTO orderDTO) {
        // Generate a new UUID for the order
        String uuid = UUID.randomUUID().toString();
        orderDTO.setOrderId(uuid); // Set autogenerated UUID as order ID
        String sql = "INSERT INTO auftrag (auftragsnummer, datum, status) VALUES (?, ?, ?)";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS)) {
            
            pstmt.setString(1, uuid);
            pstmt.setDate(2, java.sql.Date.valueOf(orderDTO.getDate()));
            pstmt.setString(3, "offen");  // status is always 'offen' when creating a new order
            pstmt.executeUpdate();
            
            try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    orderDTO.setOrderId(generatedKeys.getString(1));
                }
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
        return orderDTO;
    }

    /**
     * Adds a position to an existing order if the order's status is not "geschlossen" (closed).
     * Additionally, checks if the specified quantity of the product is available in stock before adding.
     * If the requested quantity exceeds available stock, it still adds the position but returns a message indicating the maximum available quantity.
     *
     * @param orderId      The ID of the order to add the position to.
     * @param positionDTO  The position data to add, including product ID and quantity.
     * @return The added position with its new ID and possibly a message about the available quantity.
     * @throws OrderClosedException if the order is closed.
     */
    public PositionDTO addOrderPosition(String orderId, PositionDTO positionDTO) throws OrderClosedException {
        // Ensure the order is open and exists
        if (!checkOrderExistsAndOpen(orderId)) {
            throw new OrderClosedException("Order with ID " + orderId + " is closed or does not exist.");
        }

        // Set orderId for the position
        positionDTO.setOrderId(orderId);

        // Assign a new UUID for the position
        String uuid = UUID.randomUUID().toString();
        positionDTO.setPositionId(uuid); // Update the positionDTO with the new position ID

        // Calculate available quantity for the product
        int availableQuantity = calculateAvailableProductQuantity(positionDTO.getProductId());
        
        // Check if requested quantity is available
        if (positionDTO.getQuantity() > availableQuantity) {
            // Modify the quantity to the available quantity if requested quantity exceeds availability
            //positionDTO.setQuantity(availableQuantity);
            // Optionally, add a message to positionDTO about adjusted quantity; assuming PositionDTO has a method to set messages
            //positionDTO.setMessage("Requested quantity exceeds available stock. Adjusted to available quantity: " + availableQuantity);
            System.out.println("");
            System.out.println("##########################");
            System.out.println("http://localhost:8080/api/de/v1/order/" + orderId + "/add/new/position");
            System.out.println("Requested quantity exceeds available stock. Adjusted to the available quantity, the maximum available quantities are: " + availableQuantity);
            System.out.println("##########################");
            System.out.println("");
        }

        // Proceed to add the position with either requested or adjusted quantity
        String sql = "INSERT INTO position (positionsnummer, produktnummer, auftragsnummer, menge) VALUES (?, ?, ?, ?)";
        try (Connection conn = databaseConnection.getConnection();
            PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, uuid);
            pstmt.setString(2, positionDTO.getProductId());
            pstmt.setString(3, positionDTO.getOrderId());
            pstmt.setInt(4, positionDTO.getQuantity());
            pstmt.executeUpdate();

            // Successfully added the position, return the PositionDTO (including any message about adjusted quantity)
            return positionDTO;
        } catch (SQLException e) {
            System.out.println("Error adding order position: " + e.getMessage());
            // In a real scenario, consider logging this error and potentially throwing a custom exception
            return null;
        }
    }

    /**
     * Calculates the total available quantity of a product across all warehouses.
     *
     * @param productId The ID of the product to calculate the quantity for.
     * @return The total available quantity of the product.
     */
    private int calculateAvailableProductQuantity(String productId) {
        String sql = "SELECT SUM(menge) AS availableQuantity FROM produktlagermenge WHERE produkt_fk = ?";
        try (Connection conn = databaseConnection.getConnection();
            PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, productId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("availableQuantity");
            }
        } catch (SQLException e) {
            System.out.println("Error calculating available product quantity: " + e.getMessage());
            // In a real scenario, consider logging this error and potentially throwing a custom exception
        }
        return 0; // Return 0 if product is not found or in case of error
    }

    /**
     * Deletes a specific order position by its ID.
     *
     * @param positionId the ID of the position to delete
     */
    public void deleteOrderPosition(String positionId) {
        String sql = "DELETE FROM position WHERE positionsnummer = ?";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            pstmt.setString(1, positionId);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Deletes an entire order and its associated positions by order ID.
     *
     * @param orderId the ID of the order to delete
     * @throws OrderClosedException 
     */
    @SuppressWarnings("deprecation")
    public void deleteOrder(String orderId) throws OrderClosedException {
        // Check if the order is closed
        String statusSql = "SELECT status FROM auftrag WHERE auftragsnummer = ?";
        String status = jdbcTemplate.queryForObject(statusSql, new Object[]{orderId}, String.class);
        if ("geschlossen".equals(status)) {
            throw new OrderClosedException("Order with ID " + orderId + " is closed and cannot be deleted.");
        }

        // Delete associated positions
        String sqlPosition = "DELETE FROM position WHERE auftragsnummer = ?";
        jdbcTemplate.update(sqlPosition, orderId);

        // Delete the order
        String sqlOrder = "DELETE FROM auftrag WHERE auftragsnummer = ?";
        jdbcTemplate.update(sqlOrder, orderId);
    }

    /**
     * Closes an order by verifying product availability against requested quantities,
     * and if all conditions are met, reduces stock levels and updates the order's status to 'closed'.
     * This operation is atomic, ensuring that stock levels are only adjusted if the order can be successfully closed,
     * otherwise, the operation is rolled back to maintain data integrity.
     * 
     * <p>This method demonstrates a transactional approach using JDBC, ensuring that all database
     * operations related to closing the order are either completely executed or completely rolled back.
     * 
     * @param orderId The unique identifier of the order to be closed. Must correspond to an existing order.
     * @return {@code true} if the order was successfully closed, indicating that all products were available
     *         in sufficient quantities and the stock levels have been adjusted accordingly. Returns {@code false}
     *         if the order cannot be closed due to insufficient stock for one or more products, in which case
     *         no changes are made to the database.
     * @throws InsufficientStockException if there is not enough stock available to fulfill the order. This exception
     *         contains details about the shortfall.
     * @throws OrderNotFoundException if the specified order ID does not match any existing order.
     * @throws SQLException if any database operations fail during the process. This includes failures in checking
     *         product availability, updating stock levels, or changing the order status. This exception is a
     *         general indication of a failure in database operations.
     * @throws RuntimeException if unexpected errors occur during the operation. This is a catch-all for any
     *         other exceptions that might be thrown during the execution of this method and indicates that
     *         the operation could not be completed due to unforeseen errors.
     */
    public boolean closeOrder(String orderId) throws OrderNotFoundException, InsufficientStockException {
        Connection conn = null;
        PreparedStatement pstmtCheckAvailability = null;
        PreparedStatement pstmtUpdateStock = null;
        PreparedStatement pstmtCloseOrder = null;
        ResultSet rs = null;
    
        try {
            conn = databaseConnection.getConnection();
            conn.setAutoCommit(false);
    
            // Step 1: Verify stock availability for each product in the order
            String checkAvailabilitySql = """
                SELECT p.produktnummer, SUM(p.menge) AS orderedQuantity, SUM(pl.menge) AS availableQuantity
                FROM position p
                JOIN produktlagermenge pl ON p.produktnummer = pl.produkt_fk
                WHERE p.auftragsnummer = ?
                GROUP BY p.produktnummer
                HAVING orderedQuantity > availableQuantity""";
    
            pstmtCheckAvailability = conn.prepareStatement(checkAvailabilitySql);
            pstmtCheckAvailability.setString(1, orderId);
            rs = pstmtCheckAvailability.executeQuery();
    
            if (rs.next()) {
                // Insufficient stock available for at least one product
                throw new InsufficientStockException("Insufficient stock available for the order.");
            }
    
            // Step 2: Reduce stock quantities in 'produktlagermenge' and update total quantity in 'lager'
            String updateStockSql = """
                UPDATE produktlagermenge pl
                INNER JOIN position p ON pl.produkt_fk = p.produktnummer
                SET pl.menge = pl.menge - p.menge
                WHERE p.auftragsnummer = ?""";
    
            pstmtUpdateStock = conn.prepareStatement(updateStockSql);
            pstmtUpdateStock.setString(1, orderId);
            pstmtUpdateStock.executeUpdate();
    
            // Step 3: Update order status to 'closed'
            String closeOrderSql = "UPDATE auftrag SET status = 'geschlossen' WHERE auftragsnummer = ?";
            pstmtCloseOrder = conn.prepareStatement(closeOrderSql);
            pstmtCloseOrder.setString(1, orderId);
            pstmtCloseOrder.executeUpdate();
    
            conn.commit();
            return true;
        } catch (SQLException e) {
            try {
                if (conn != null) conn.rollback(); // Rollback in case of an error
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            e.printStackTrace();
            return false;
        } finally {
            // Close all JDBC resources including ResultSet, PreparedStatements, and Connection
            closeResources(rs, new PreparedStatement[]{pstmtCheckAvailability, pstmtUpdateStock, pstmtCloseOrder}, conn);
        }
    }
    
    /**
     * Closes JDBC resources including ResultSet, PreparedStatements, and Connection.
     * This method ensures that all database resources are properly closed to prevent resource leaks.
     * It also restores the auto-commit mode to its default state before closing the connection.
     *
     * @param rs         The ResultSet to be closed. Can be null if there's no ResultSet to close.
     * @param statements An array of PreparedStatements to be closed. It can include multiple statements or be null if there are none.
     * @param conn       The Connection to be closed. Can be null if there's no Connection to close.
     */
    private void closeResources(ResultSet rs, PreparedStatement[] statements, Connection conn) {
        try {
            // Attempt to close the ResultSet if it's not null.
            if (rs != null) {
                rs.close();
            }
            // Loop through each PreparedStatement and close it if it's not null.
            for (PreparedStatement stmt : statements) {
                if (stmt != null) {
                    stmt.close();
                }
            }
            // Check if the Connection is not null and close it.
            // Before closing, it restores the auto-commit mode to true, the default state.
            if (conn != null) {
                conn.setAutoCommit(true); // Restore auto-commit before closing
                conn.close();
            }
        } catch (SQLException e) {
            // Print the stack trace of any SQLException that occurs during the closing process.
            e.printStackTrace();
        }
    }

    /**
     * Checks if an order exists in the database.
     * 
     * @param orderId The ID of the order to check.
     * @return true if the order exists, false otherwise.
     */
    public boolean checkOrderExists(String orderId) {
        String sql = "SELECT COUNT(*) FROM auftrag WHERE auftragsnummer = ?";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
             
            pstmt.setString(1, orderId);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    int count = rs.getInt(1);
                    return count > 0;
                }
            }
        } catch (SQLException e) {
            System.out.println("Error checking order existence: " + e.getMessage());
            // Consider appropriate exception handling strategy
        }
        return false;
    }

    /**
     * Checks if an order exists and is open.
     *
     * @param orderId The ID of the order.
     * @return True if the order exists and is open, false otherwise.
     * @throws OrderNotFoundException if the order does not exist.
     * @throws OrderClosedException if the order is closed.
     */
    public boolean checkOrderExistsAndOpen(String orderId) throws OrderNotFoundException, OrderClosedException {
        String sql = "SELECT status FROM auftrag WHERE auftragsnummer = ?";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            pstmt.setString(1, orderId);
            ResultSet rs = pstmt.executeQuery();
            
            if (rs.next()) {
                String status = rs.getString("status");
                if ("geschlossen".equals(status)) {
                    throw new OrderClosedException("Order with ID " + orderId + " is closed.");
                }
                return true; // Order exists and is open
            } else {
                throw new OrderNotFoundException("Order with ID " + orderId + " not found.");
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            // Consider re-throwing as a runtime exception or specific checked exception as needed
            throw new RuntimeException("Database error occurred while checking order status.", e);
        }
    }

    /**
     * Deletes a specific position from an order only if the order's status is "offen" (open).
     *
     * @param orderId    The ID of the order from which to delete the position.
     * @param positionId The ID of the position to delete.
     * @throws Exception 
     * @throws OrderClosedException If the order's status is "geschlossen" (closed).
     * @throws ResponseStatusException With {@code HttpStatus.NOT_FOUND} if either the position does not exist
     *         or it does not belong to the specified order.
     */
    @SuppressWarnings("deprecation")
    public void deleteOrderPosition(String orderId, String positionId) throws OrderClosedException {
        // Check if the order is open
        try {
            String orderStatusSql = "SELECT status FROM auftrag WHERE auftragsnummer = ?";
            String status = jdbcTemplate.queryForObject(orderStatusSql, new Object[]{orderId}, String.class);
            if ("geschlossen".equals(status)) {
                throw new OrderClosedException("Order with ID " + orderId + " is closed.");
            }
        } catch (EmptyResultDataAccessException e) {
            throw new OrderNotFoundException("Order with ID " + orderId + " not found.");
        }

        // Verify if the position belongs to the given order
        String verifySql = "SELECT COUNT(*) FROM position WHERE positionsnummer = ? AND auftragsnummer = ?";
        int count = jdbcTemplate.queryForObject(verifySql, new Object[]{positionId, orderId}, Integer.class);
        if (count == 0) {
            throw new PositionNotFoundException("Position not found or does not belong to the specified order.");
        }

        // Delete the position
        String deleteSql = "DELETE FROM position WHERE positionsnummer = ?";
        int affectedRows = jdbcTemplate.update(deleteSql, positionId);
        if (affectedRows == 0) {
            // This should not occur due to the checks above
            throw new PositionNotFoundException("Failed to delete the position.");
        }
    }
}