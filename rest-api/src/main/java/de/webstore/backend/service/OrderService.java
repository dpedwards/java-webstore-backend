/* Copyright Davain Pablo Edwards core8@gmx.net. Licensed https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en */
package de.webstore.backend.service;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import de.webstore.backend.dto.OrderDTO;
import de.webstore.backend.dto.PositionDTO;
import de.webstore.backend.exception.OrderClosedException;
import de.webstore.backend.exception.OrderNotFoundException;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import de.webstore.backend.config.DatabaseConnection;

/**
 * Service layer for managing orders.
 * <p>
 * This class provides services for retrieving, creating, and managing orders and their positions,
 * interfacing with the database to perform these operations.
 */
@Service
public class OrderService {

    // Database connection dependency injected by Spring
    private final DatabaseConnection databaseConnection;

    @Autowired
    public OrderService(DatabaseConnection databaseConnection) {
        this.databaseConnection = databaseConnection;
    }

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * Retrieves all orders from the database.
     *
     * @return a list of all orders
     */
    public List<OrderDTO> findAll() {
        List<OrderDTO> orders = new ArrayList<>();
        String sql = "SELECT * FROM auftrag";

        // Try-with-resources statement ensures that each resource is closed at the end of the statement
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql);
             ResultSet rs = pstmt.executeQuery()) {
            
            while (rs.next()) {
                OrderDTO order = new OrderDTO();
                order.setOrderId(rs.getString("auftragsnummer"));
                order.setDate(rs.getDate("Datum").toLocalDate());
                order.setStatus(rs.getString("status"));
                orders.add(order);
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
        return orders;
    }

    /**
     * Finds a specific order by its ID and throws OrderNotFoundException if not found.
     *
     * @param orderId the order ID
     * @return the found order
     * @throws OrderNotFoundException if the order with the given ID is not found
     */
    public OrderDTO findById(String orderId) {
        OrderDTO order = null;
        String sql = "SELECT * FROM auftrag WHERE auftragsnummer = ?";

        try (Connection conn = databaseConnection.getConnection();
            PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            pstmt.setString(1, orderId);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    order = new OrderDTO();
                    order.setOrderId(rs.getString("auftragsnummer"));
                    order.setStatus(rs.getString("status"));
                    order.setDate(rs.getDate("datum").toLocalDate());
                } else {
                    // If the order with the specified ID is not found, throw OrderNotFoundException
                    throw new OrderNotFoundException("Order with ID " + orderId + " not found.");
                }
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            // Consider wrapping and rethrowing SQLException as a runtime exception or a custom checked exception
        }
        return order;
    }

    /**
     * Creates a new order in the database.
     *
     * @param orderDTO the order to be created
     * @return the created order with its new ID
     */
    public OrderDTO createOrder(OrderDTO orderDTO) {
        // Generate a new UUID for the order
        String uuid = UUID.randomUUID().toString();
        orderDTO.setOrderId(uuid); // Set autogenerated UUID as order ID
        String sql = "INSERT INTO auftrag (auftragsnummer, datum, status) VALUES (?, ?, ?)";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS)) {
            
            pstmt.setString(1, uuid);
            pstmt.setDate(2, java.sql.Date.valueOf(orderDTO.getDate()));
            pstmt.setString(3, "offen");  // status is always 'offen' when creating a new order
            pstmt.executeUpdate();
            
            try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    orderDTO.setOrderId(generatedKeys.getString(1));
                }
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
        return orderDTO;
    }

    /**
     * Adds a position to an existing order if the order's status is not "geschlossen".
     * The method has been updated to accept an order ID and a PositionDTO.
     *
     * @param orderId the ID of the order to add the position to
     * @param positionDTO the position data to add
     * @return the added position with its new ID, or null if the order is closed or an error occurs
     * @throws OrderClosedException if the order is closed
     */
    public PositionDTO addOrderPosition(String orderId, PositionDTO positionDTO) throws OrderClosedException {
        // Before attempting to add the position, ensure the order is open and exists
        if (!checkOrderExistsAndOpen(orderId)) {
            throw new OrderClosedException("Order with ID " + orderId + " is closed or does not exist.");
        }

        // Assuming checkOrderExistsAndOpen throws an exception if the order is closed or does not exist,
        // the following code will only run if the order is open and exists.

        // Assign a new UUID for the position
        String uuid = UUID.randomUUID().toString();
        positionDTO.setPositionNumber(uuid); // Assuming PositionDTO can store the position ID as a String

        String sql = "INSERT INTO position (positionsnummer, produktnummer, auftragsnummer, menge) VALUES (?, ?, ?, ?)";

        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, uuid);
            pstmt.setString(2, positionDTO.getProductId());
            pstmt.setString(3, orderId); // Use the orderId passed to the method
            pstmt.setInt(4, positionDTO.getQuantity());

            pstmt.executeUpdate();

            // Successfully added the position, return the PositionDTO with the new ID
            return positionDTO;
        } catch (SQLException e) {
            System.out.println("Error adding order position: " + e.getMessage());
            // Depending on your error handling strategy, you might want to throw an exception here
            return null;
        }
    }

    /**
     * Deletes a specific order position by its ID.
     *
     * @param positionId the ID of the position to delete
     */
    public void deleteOrderPosition(String positionId) {
        String sql = "DELETE FROM position WHERE positionsnummer = ?";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            pstmt.setString(1, positionId);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Deletes an entire order and its associated positions by order ID.
     *
     * @param orderId the ID of the order to delete
     */
    public void deleteOrder(String orderId) {
        String sqlOrder = "DELETE FROM auftrag WHERE auftragsnummer = ?";
        String sqlPosition = "DELETE FROM position WHERE auftragsnummer = ?";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmtPosition = conn.prepareStatement(sqlPosition);
             PreparedStatement pstmtOrder = conn.prepareStatement(sqlOrder)) {
            
            // Delete order positions first
            pstmtPosition.setString(1, orderId);
            pstmtPosition.executeUpdate();
            
            // Then delete the order itself
            pstmtOrder.setString(1, orderId);
            pstmtOrder.executeUpdate();
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Closes an order by checking product availability, adjusting stock levels, and updating the order status.
     * This method is transactional to ensure data consistency and integrity.
     * <p>
     * Steps:
     * 1. Checks the availability of all products in the order.
     * 2. If all products are available, reduces stock quantities and updates the order status to 'closed'.
     * 3. If not all products are available, performs a rollback to maintain data integrity.
     * <p>
     * This method uses JDBC connections and prepares statements for database interactions,
     * demonstrating how to handle transactions manually, including rollbacks in case of insufficient stock or errors.
     *
     * @param orderId The ID of the order to be closed.
     * @return true if the order is successfully closed, false otherwise.
     */
    @Transactional
    public boolean closeOrder(String orderId) {
        // Initialize JDBC objects
        Connection conn = null;
        PreparedStatement pstmtCheck = null;
        PreparedStatement pstmtUpdate = null;
        PreparedStatement pstmtCloseOrder = null;
        ResultSet rs = null;
        boolean allProductsAvailable = true;
        
        try {
            // Obtain a connection and disable auto-commit for transactional control
            conn = databaseConnection.getConnection();
            conn.setAutoCommit(false);

            // Check the availability of products for all order positions
            String checkAvailabilitySql = "SELECT p.produktnummer, (l.menge - p.menge) AS available FROM position p " +
                                          "JOIN produktlagermenge l ON p.produktnummer = l.produkt_fk " +
                                          "WHERE p.auftragsnummer = ?";
            pstmtCheck = conn.prepareStatement(checkAvailabilitySql);
            pstmtCheck.setString(1, orderId);
            rs = pstmtCheck.executeQuery();

            // Determine if all products are available
            while (rs.next()) {
                if (rs.getInt("available") < 0) {
                    allProductsAvailable = false;
                    break;
                }
            }

            if (allProductsAvailable) {
                // Reduce stock quantities for all order positions
                String updateStockSql = "UPDATE produktlagermenge l " +
                                        "JOIN position p ON l.produkt_fk = p.produktnummer " +
                                        "SET l.menge = l.menge - p.menge " +
                                        "WHERE p.auftragsnummer = ?";
                pstmtUpdate = conn.prepareStatement(updateStockSql);
                pstmtUpdate.setString(1, orderId);
                pstmtUpdate.executeUpdate();

                // Update order status to 'closed'
                String closeOrderSql = "UPDATE auftrag SET status = 'geschlossen' WHERE auftragsnummer = ?";
                pstmtCloseOrder = conn.prepareStatement(closeOrderSql);
                pstmtCloseOrder.setString(1, orderId);
                pstmtCloseOrder.executeUpdate();

                // Commit the transaction to finalize changes
                conn.commit();
                return true;
            } else {
                // Insufficient stock, perform a rollback
                conn.rollback();
                return false;
            }
        } catch (SQLException e) {
            // Handle SQL exceptions by attempting to rollback the transaction
            try {
                if (conn != null) {
                    conn.rollback();
                }
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            e.printStackTrace();
            return false;
        } finally {
            // Clean up JDBC resources in the finally block to ensure they are always closed
            try {
                if (rs != null) rs.close();
                if (pstmtCheck != null) pstmtCheck.close();
                if (pstmtUpdate != null) pstmtUpdate.close();
                if (pstmtCloseOrder != null) pstmtCloseOrder.close();
                if (conn != null) {
                    conn.setAutoCommit(true); // Restore auto-commit mode
                    conn.close();
                }
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        }
    }

    /**
     * Checks if an order exists in the database.
     * 
     * @param orderId The ID of the order to check.
     * @return true if the order exists, false otherwise.
     */
    public boolean checkOrderExists(String orderId) {
        String sql = "SELECT COUNT(*) FROM auftrag WHERE auftragsnummer = ?";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
             
            pstmt.setString(1, orderId);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    int count = rs.getInt(1);
                    return count > 0;
                }
            }
        } catch (SQLException e) {
            System.out.println("Error checking order existence: " + e.getMessage());
            // Consider appropriate exception handling strategy
        }
        return false;
    }

    /**
     * Checks if an order exists and is open.
     *
     * @param orderId The ID of the order.
     * @return True if the order exists and is open, false otherwise.
     * @throws OrderNotFoundException if the order does not exist.
     * @throws OrderClosedException if the order is closed.
     */
    public boolean checkOrderExistsAndOpen(String orderId) throws OrderNotFoundException, OrderClosedException {
        String sql = "SELECT status FROM auftrag WHERE auftragsnummer = ?";
        try (Connection conn = databaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            pstmt.setString(1, orderId);
            ResultSet rs = pstmt.executeQuery();
            
            if (rs.next()) {
                String status = rs.getString("status");
                if ("closed".equals(status)) {
                    throw new OrderClosedException("Order with ID " + orderId + " is closed.");
                }
                return true; // Order exists and is open
            } else {
                throw new OrderNotFoundException("Order with ID " + orderId + " not found.");
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            // Consider re-throwing as a runtime exception or specific checked exception as needed
            throw new RuntimeException("Database error occurred while checking order status.", e);
        }
    }

    /**
     * Deletes a specific position from an order.
     *
     * This method first verifies that the specified position exists within the given order
     * by executing a SQL query that counts the occurrences of the position ID associated with
     * the order ID. If no such association is found (i.e., the count is 0), it indicates
     * that either the position does not exist or it does not belong to the specified order.
     * In such cases, a {@link ResponseStatusException} is thrown with the status `HttpStatus.NOT_FOUND`
     * to indicate that the resource was not found.
     *
     * If the verification is successful, indicating that the position belongs to the order,
     * the method proceeds to delete the position from the database using a SQL delete statement.
     * The deletion is based solely on the position ID, as the prior verification ensures
     * the position's association with the given order.
     *
     * After attempting the deletion, if no rows are affected, which theoretically should not
     * happen due to the initial verification, the method throws a generic {@link Exception}
     * indicating a failure to delete the position. This acts as a safeguard to handle
     * unexpected scenarios where the deletion might not proceed as expected.
     *
     * Note: The method uses {@code @SuppressWarnings("deprecation")} to suppress warnings
     * related to deprecated methods used in the implementation. This is generally used
     * to maintain compatibility with older API versions while acknowledging that the method
     * or constructor used is deprecated.
     *
     * @param orderId the ID of the order from which to delete the position, represented as a {@link String}.
     * @param positionId the ID of the position to delete, also represented as a {@link String}.
     * @throws Exception if the deletion fails after verification, indicating an unexpected error occurred.
     * @throws ResponseStatusException with {@code HttpStatus.NOT_FOUND} if either the position does not exist
     *         or it does not belong to the specified order, based on the initial verification query.
     */
     @SuppressWarnings("deprecation")
    public void deleteOrderPosition(String orderId, String positionId) throws Exception {
        // Verify if the position belongs to the given order
        String verifySql = "SELECT COUNT(*) FROM position WHERE positionsnummer = ? AND auftragsnummer = ?";
        int count = jdbcTemplate.queryForObject(verifySql, new Object[]{positionId, orderId}, Integer.class);
        if (count == 0) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Order or position not found");
        }

        // Delete the position
        String deleteSql = "DELETE FROM position WHERE positionsnummer = ?";
        int affectedRows = jdbcTemplate.update(deleteSql, positionId);
        if (affectedRows == 0) {
            // This should not happen due to the previous check, but it's a safeguard.
            throw new Exception("Failed to delete the position");
        }
    }
}